---
title: "Ch 2. The R Language"
output: rmarkdown::github_document
---
```{r, echo = FALSE}
knitr::opts_chunk$set(
  fig.path = "Plots/FIG-"
)
```

### 2.2 A Quick Tour of R's Capabilities Using ANOVA, SEM on Consumer Survey Data

**Assignment** uses the assignment operator "<-" to create a named object that comprises of other objects. 

**c()** denotes a vector

```{r}
# Testing
x <- c(2,4,6,8)
x
```
Install some add-on packages that we will need

```{r}
#install.packages(c("lavaan","semPlot","corrplot","multcomp"))
```
This data set contains observations from sales and product satisfaction survey.

* It has 500 consumers' answers
* **iProdSAT:** satisfaction with a product
* **iSalesSAT:** satisfaction with sales experience
* **iProdREC:** likelihood to recommend the product
* **iSalesREC:** likelihood to recommend the salesperson
* **Segement:** numerically-coded segment

The function **`factor`** is used to encode a vector as a factor/category. For this data set, we set `Segment` to be a categorical factor variable. Observe Segment is now a factor data type:

```{r}
satData <- read.csv("http://goo.gl/UDv12g")
satData$Segment <- factor(satData$Segment)
head(satData)
```

Next we can plot the corr matrix excluding the categorical `Segment` variable in column 3 by specifying -3 in our slice of `satData`.

`corrplot.mixed(corr)`: Using mixed methods to visualize a correlation matrix.

`cor(x,y = NULL)`: computes the correlation of x and y if these are vectors.
```{r}
library(corrplot)  # In order to use package
corrplot.mixed(cor(satData[,-3]))
```
*Observations*:

* All variables are positively correlated
* Satisfaction metrics are strongly correlated with one another (0.41)
* Recommendation metrics are strongly correlated with one another (0.46)

#### Q. Does product satisfaction differ by segment? 

We compute a mean satisfaction for each segment using the `aggregate()` function to observe sample means of product satisfaction per segment

`aggregate(x, by, data, function..)` splits the data into subsets and computes summary stats for each subset

```{r}
aggregate(iProdSAT ~ Segment, satData, mean)
```
*Observe*: Segment 4 has the highest level of satisfaciton while Segment 1 has the lowest level of satisfaction

#### Q. Are the differences in satisfaction statistically significant?

Perform a one-way ANOVA across the segments:

`aov(formula, data=NULL)`: fits a balanced-design anova model. Formula specifies the model

```{r}
satData.anova <- aov(iProdSAT ~ -1 + Segment, satData)  # why is there a -1?
summary(satData.anova)
```
*Observe*: There are significant differences between the sample means

We plot the ANOVA model to visualize confidence intervals for mean product satisfaction per segment:

`par(..)` can be used to set or query graphical parameters. Parameters are set by specifying them as arguments to par in `tag = value` form

`mar` A numerical vector of the form `c(bottom, left, top, right)` which gives the number of lines of margin to be specified on the four sides of the plot. The default is c(5, 4, 4, 2) + 0.1. 

'glht(model)`: General linear hypotheses and multiple comparisons for parametric models, including generalized linear models, linear mixed effects models, and survival models.
  
`model`: a fitted model, for example an object returned by lm, glm, or aov etc. It is assumed that coef and vcov     methods are available for model.
```{r}
#install.packages("zoo")
library(multcomp)
```


```{r}
par(mar=c(4,8,4,2)) # setting margin parameters for plot
plot(glht(satData.anova))
```
*Observe*: 

* Seg 1, 2 and 3 differ modestly while Seg 4 is much more satisfied than the others
* Seg 1 has a wider confidence interval than the other segments

##### Likert Rating Scales:

X-axis represents a **Likert rating scale** ranging from 1 to 7 for product satisfaction. "Likert scales are survey questions that offer a range of answer options — from one extreme attitude to another, like “extremely likely” to “not at all likely.” Typically, they include a moderate or neutral midpoint.

Likert scales (named after their creator, American social scientist Rensis Likert) are quite popular because they are one of the most reliable ways to measure opinions, perceptions, and behaviors.""

Src: https://www.surveymonkey.com/mp/likert-scale/

##### Structural Equation Models

Many marketing analysts are interested in SEM's and R has multiple pkgs to fit SEMs. "Attitudes, opinions and personality traits are important drivers of consumer behavior, but they are latent constructs and marketing researchers cannot actually observe them or measure them directly. We can only make inferences about them from what we can observe, responses to questionnaire items, for example. Measuring latent constructs is challenging and we must also incorporate estimates of measurement error into our models. SEM excels at both of these tasks."

SEM is suited for causal analysis especially when there's MTC in the data set. It can be used on social media data, transactional data, economic data, and etc. SEM helps us observe latent segments of consumers with different perceptions or attributes (aka Driver Segmentation) or latent variables within the data set 

Src: http://www.kdnuggets.com/2017/03/structural-equation-modeling.html

"SEM, is a very general, chiefly linear, chiefly cross-sectional statistical modeling technique. Factor analysis, path analysis and regression all represent special cases of SEM. In SEM, interest usually focuses on latent constructs--abstract psychological variables like "intelligence" or "attitude toward the brand"--rather than on the manifest variables used to measure these constructs. Measurement is recognized as difficult and error-prone. By explicitly modeling measurement error, SEM users seek to derive unbiased estimates for the relations between latent constructs. To this end, SEM allows multiple measures to be associated with a single latent construct."
Src 2: http://www2.gsu.edu/~mkteer/sem.html

#### Q. Do latent variables affect satisfaction or likelihood-to-recommend?

By fitting an SEM to the satisfaction data, we can define a model with latent vars for both satisfaction and recommendation. The SAT latent var is manifested in the two satisfaction metrics while the REC latent var is manifested in the two recommendation metrics. 

As marketers, we wish to understand, is the latent REC var affected by the latent SAT var?
```{r}

satModel <- "SAT =~ iProdSAT + iSalesSAT 
             REC =~ iProdREC + iSalesREC
             REC ~ SAT "
# line 1: Latent SAT var is observed as items iProdSAT and iSalesSAT
# line 2: Latent REC var is observated as items iProdREC and iSalesREC
# line 3: RECommendation varies with SATisfaction

```

Now we fit the model to the data using `lavaan` package:
```{r}
library(lavaan)

sat.fit <- cfa(satModel, data=satData)
summary(sat.fit, fit.m=TRUE)
```
*Observe*: the model fits the data well with a Comparative Fit Index (CFI) ~ 1 . See Ch. 10

We can visualize the SEM using the `semPlot` package in order to create a structural model. A **structural model** includes path loadings for a model and the estimated coefficient between latent vars.
```{r}
#install.packages(c("lme4","car","psych", "ggplot2","htmlwidgets","data.table","pkgconfig"))

```

```{r}
library(semPlot)
semPaths(sat.fit, what="est",
         residuals=FALSE, intercepts=FALSE, nCharNodes=9)
```
*Observe*:

* Each proposed latent var is highly loaded (contingent) on its observed (manifested) survey items. (1.0 and 1.7 for SAT, 1.0 and .90 for REC)
* Customers' latent satisfaction (SAT) is shown to have a strong association or relationship with their likelihood to recommend (REC) with an estimated coefficient of 0.76. See Ch. 10 FMI.

### 2.4 Basic Objects in R

The 3 most important data types are vectors, lists, and data frames. 

#### Vectors

A 1D collection of data points of the same type. 

* The command `c()` indicates to R that we are entering the elements of a vector. 
* `summary()` provides an overall summary of the object. For vectors of numerics, range and central tendency stats are given. For vectors of strings, it reports the length of vector and type of elements
* Indexing denotes particular elements of a data structure
* Vectors are indexed with square brackets `[#]`
```{r}
# Vector assignment
x <- c(2,4,6,8)
x

xNum <- c(1, 3.1453, 5, 7)
xLog <- c(TRUE, FALSE, TRUE, TRUE)
xChar <- c("foo", "bar", "boo", "far")
xMix <- c(1, TRUE, 3, "Hello, World!")  # special characters within quotations are included as part of char

xNum
```
```{r}
# Vectors may be appended/combined using c():

x2 <- c(x,x)
x2
```
```{r}
# Summary function
print(summary(xNum))
cat("\n")
print(summary(xMix))
cat("\n")
print(summary(xLog))  # Provides True False counts

```
```{r}
# Indexing
xNum[2]

# Arithmetic operations
x2 +1
x2 * 2
x2 * pi
```

```{r}
# Recycling: Reusing the vector of shortest length if lengths do not match

x + x2
length(x)
length(x2)
```

When creating a vector, R automatically assigns a data type or class to all elements in the most *generalized* format. For example, c(1,2,3.4) would be *coerced* to type `double` because of the real number 3.5 is more *general* than the integer 1.

```{r}
c(1,2,3.5)
c(1.30, 2.3958, 3)
```

The most generalized format for `xMix` is `char`:
```{r}
str(xMix)  # str for structure
```
```{r}
# Arithmetic operations based on matching/non-matching data types

xNum[1]
xMix[1]
xNum[1] + 1
xMix[1] + 1  # throws an error due to char + numtype

```
To explicity coerce a char type to numeric, use `as.numeric()` function
```{r}
as.numeric(xMix[1]) + 1
```
```{r}
browseVignettes()  # A helpful function for providing info on all installed packages
```

```{r}
# To create integer sequences, use ":"
xSeq <- 1:10
xSeq
str(xSeq)

# When applying math to int sequences, be careful of order of operation. ":" is applied first before any other operation
1:5*2
1:(5*2)

```
Sequences are useful for indexing and you can use sequences inside indexing [ ]:
```{r}
xNum
xNum[2:4]

myStart <- 2
xNum[myStart:sqrt(myStart + 7)] # Evals to xNum[2:3]
```
For more sophisticated sequences, use `seq()` for sequence and `rep()` for replicated sequences. In the last example below, we look at the inner expression sequence `[-3, 1,...13]`. Each ELEMENT of that vector will be replicated n-times as specified in the 2nd argument to `rep()`. Replicate, not multiply! 

We can also exclude items by using negative indices `xSeq[-1]` i.e. exclude first element
```{r}
seq(from=-5, to=28, by=4) # start from -5 to 28 and step -4
rep(c(1,2,3), each=3)  # replicate the vector 3 times
seq(from=-3, to=13, by=4)
rep(seq(from=-3, to=13, by=4), c(1,2,3,2,1))
```
```{r}
# Exclude items
xSeq
xSeq[-1] # Excluding 1st element
xSeq[c(-1,-10)]  # Excluding more than one element requires a vector argument
```

```{r}
# 1 is the start of the row. It indicates the vector position index of the 1st item printed on each row of output
1:300
```
```{r}
xNum[2:4]
xSub <- xNum[2:4]
xSub

# Indexing also works with logical values
xNum
xNum[c(TRUE, TRUE, FALSE, FALSE)]

# We can also index based on conditions 
xNum[xNum >= 5]
```

